# -*- coding: utf-8 -*-
"""Restful API & Flask

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1maogHruHsLtjAcyyIrjQHBLD4ua7gcXd

**THEORY QUSTION OF RESTFUL API & FLASK**

Q-1  What is a RESTful API?


  ANS-- A RESTful API (Representational State Transfer API) is a type of web API that follows the principles of REST architecture, which is a set of design guidelines for building scalable web services.

  1- Client-Server Architecture
    
    * The client (e.g., a browser or mobile app) makes requests.

    * The server processes those requests and sends back responses.

    * They operate independently.

  2 - Stateless

     * Each request from a client must contain all the information needed to process it.

     * The server does not store any session information about the client between requests.

   3- Resources and URLs

     * Resources (data) are identified using URLs.

   4- | HTTP Method | Action         | Description               |
| ----------- | -------------- | ------------------------- |
| `GET`       | Read           | Retrieve data             |
| `POST`      | Create         | Submit new data           |
| `PUT`       | Update/Replace | Replace existing data     |
| `PATCH`     | Modify         | Update part of a resource |
| `DELETE`    | Delete         | Remove data               |

Q-2  Explain the concept of API specification.

  ANS-- An API specification is a detailed, formal description of how an API works — what it offers, how to use it, and what developers can expect when they interact with it.


 Concepts in an API Specification:

   2. HTTP Methods
      
    Specifies what methods are allowed at each endpoint:

  * GET, POST, PUT, DELETE, PATCH, etc.

   3. Request Format:-

     * Parameters (query, path, header, body)

     * Required fields

     * Data types

Q-3  What is Flask, and why is it popular for building APIs?

  ANS-- Flask is a lightweight, Python-based web framework used for building web applications and APIs. It’s particularly popular for creating RESTful APIs due to its simplicity, flexibility, and ease of use.


 Why Flask Is Popular for Building APIs

   1. Minimal and Flexible
     
     * You start with a blank slate — no assumptions or enforced architecture.

     * You can design your API exactly how you want it without fighting the framework.

  2. Simple and Intuitive

    * Great for beginners and small-to-medium applications.

    * Clean and readable syntax that aligns well with Pythonic principles.

 3. Built-in Development Server
   
   * Flask has an easy-to-use local server, perfect for rapid prototyping and debugging.

 4. Strong Community and Ecosystem
   
   * Large number of extensions (like Flask-RESTful, Flask-JWT, Flask-SQLAlchemy).

   * Helpful documentation and tutorials available.

Q-4  What is routing in Flask?

  ANS-- Routing in Flask is the mechanism that maps URLs (web addresses) to Python functions in your application. These functions are called view functions, and they define what should happen when someone accesses a particular route (URL) in the app.

Q-5 How do you create a simple Flask application?

  ANS-- from flask import flask

    app = flask(__name__)

define a route

    @app.route("/")
    def home():
      return "hello, flask!"

    run the app
        
        if__name__=="__main__":
        app.run(debug=true)

Q- 6 What are HTTP methods used in RESTful APIs?

   ANS-- In RESTful APIs, HTTP methods define the type of operation a client wants to perform on a resource (like data in a database). These methods are the foundation of how REST APIs work.

  
| Method      | Purpose                            | Typical Use Case                       |
| ----------- | ---------------------------------- | -------------------------------------- |
| **GET**     | Retrieve data                      | Get a list of users or a specific user |
| **POST**    | Create new data                    | Add a new user                         |
| **PUT**     | Update/replace existing data       | Replace user information               |
| **PATCH**   | Partially update existing data     | Update only the user's email           |
| **DELETE**  | Delete data                        | Remove a user                          |
| **OPTIONS** | Describe communication options     | Check what methods are allowed         |
| **HEAD**    | Like GET, but returns only headers | Check if a resource exists             |

Q-7 What is the purpose of the @app.route() decorator in Flask?

  ANS-- The @app.route() decorator in Flask is used to bind a URL path to a Python function — called a view function. This tells Flask what code to execute when a particular URL is requested by a client (like a web browser or an API call).


  EXAMPLE:-
      
       from flask import Flask
app = Flask(__name__)

@app.route('/')
def home():
    return "Welcome to the homepage!"

 * When a user visits /, the home() function is executed.

 * The return value ("Welcome to the homepage!") is sent back as the response.

Q-8 What is the difference between GET and POST HTTP methods?

  ANS-- The difference between GET and POST HTTP methods lies mainly in how data is sent from the client to the server and what each method is intended for.



    | Feature               | **GET**                                           | **POST**                              |
| --------------------- | ------------------------------------------------- | ------------------------------------- |
| **Purpose**           | Retrieve data (read-only)                         | Submit data (create or process data)  |
| **Data Location**     | Sent in URL (query string)                        | Sent in request body                  |
| **Visible in URL?**   |  Yes                                             |  No (more secure for sensitive data) |
| **Caching**           |  Can be cached                                   |  Not typically cached                |
| **Bookmarkable**      |  Yes (URL can be saved)                          |  No                                  |
| **Idempotent**        |  Yes (multiple identical requests → same result) |  No (may create duplicates)          |
| **Use Case Examples** | Get user info, search, load page                  | Submit a form, register, login        |

Q-9 How do you handle errors in Flask APIs?

  ANS-- In a Flask API, error handling is important for sending clear, consistent, and meaningful responses to the client when something goes wrong (e.g., bad request, not found, internal error).

 EXAMPLE:- Custom Error Handlers

     from flask import jsonify

@app.errorhandler(404)
def not_found(error):
    return jsonify({"error": "Resource not found"}), 404

@app.errorhandler(400)
def bad_request(error):
    return jsonify({"error": "Bad request"}), 400

@app.errorhandler(500)
def server_error(error):
    return jsonify({"error": "Internal server error"}), 500

Q-10 How do you connect Flask to a SQL database?

   ANS-- Connecting Flask to a SQL database involves using a database library to manage the connection and interact with the database. The most common and recommended way is by using Flask-SQLAlchemy, which integrates the SQLAlchemy ORM with Flask.

Q-11  What is the role of Flask-SQLAlchemy?

  ANS-- Flask-SQLAlchemy is an extension for Flask that integrates SQLAlchemy—a powerful Python ORM (Object Relational Mapper)—with the Flask web framework.

It makes it much easier to work with databases in Flask applications by providing:

  * Simple configuration

  * Automatic integration with Flask’s app context

  * Helper methods to manage database sessions

  * Declarative syntax for defining models (tables)

Q-12 What are Flask blueprints, and how are they usefu?


  ANS-- Flask Blueprints are a feature in Flask that allow you to organize your application into smaller, reusable components.


  |  Use Case                                             |  Benefit                               |
| ------------------------------------------------------ | ---------------------------------------- |
| Your app is getting large                              | Keeps code organized and modular         |
| You have different app sections (e.g. auth, blog, API) | Each section can be isolated             |
| You want to reuse code across apps                     | Blueprints are reusable                  |
| You work with a team                                   | Easier collaboration and structure       |
| You want cleaner routing                               | Use `url_prefix` to group related routes |

Q-13 What is the purpose of Flask's request object?

  ANS-- The request object in Flask is used to access data sent by the client to the server. It allows your Flask app to read incoming HTTP request data, such as:

  * Form inputs

  * JSON payloads

  * URL query parameters

  * File uploads

  * HTTP headers

  * Cookies

  * Request method (GET, POST, etc.)

Q- 14  How do you create a RESTful API endpoint using Flask?


   ANS-- To create a RESTful API endpoint using Flask, you typically:

   * Define a Route:Use the @app.route() decorator to define the URL path for the endpoint.

   * Specify HTTP Methods: Use the methods argument in the @app.route() decorator to specify which HTTP methods are allowed for this endpoint (e.g., methods=['GET', 'POST']).

   * Access Request Data: Use the request object to access data sent by the client (query parameters, form data, JSON data, etc.).

    *  Process Data: Perform the necessary logic based on the request data and the HTTP method.

   * Return a Response: Return a response, typically in JSON format, using jsonify() or by creating a Response object with the appropriate status code and data.

Q- 15 What is the purpose of Flask's jsonify() function?

  ANS-- The purpose of Flask's jsonify() function is to convert Python data structures (like dictionaries, lists, etc.) into a JSON-formatted HTTP response. It also sets the correct MIME type (application/json) and status code for the response.

Key Features of jsonify():

  1. Serialization:

     * Converts Python dictionaries, lists, and other JSON-serializable types into a JSON string.

  2. Content-Type Header:
   
     * Automatically sets the response header to Content-Type: application/json, which tells the client that the response is in JSON format.

  3. Returns a Response Object:
     
     * Unlike json.dumps(), which just returns a JSON string, jsonify() returns a full Flask Response object, making it easier to return from a route.

Q-16  Explain Flask’s url_for() function.

  ANS-- Flask’s url_for() function is used to build a URL for a specific function (usually a route handler) by its name, rather than hardcoding URLs into your application. It helps keep your code maintainable and flexible.


  PURPOSE OF url_for()

  * Generates dynamic URLs by referencing the name of a view function, not the actual URL path.

  * Ensures consistency: if your route path changes, url_for() will still generate the correct URL.

  * Can include query parameters or URL parameters.

  BASIC SYNTAX

  * endpoint: The name of the view function.

  * **values: Variables to build the URL (used for dynamic segments or query strings).

Q-17  How does Flask handle static files (CSS, JavaScript, etc.)?

  ANS--Flask handles static files (like CSS, JavaScript, images, fonts, etc.) through a built-in mechanism that serves them from a special static/ folder in your project directory.


Default Structure for Static Files in Flask.

  your_app/
│
├── app.py
├── static/
│   ├── style.css
│   ├── script.js
│   └── images/
│       └── logo.png
└── templates/
    └── index.html

Q-18  What is an API specification, and how does it help in building a Flask API?

  ANS-- An API specification is a formal, structured description of how an API works — what endpoints are available, what requests they accept, and what responses they return. It serves as a blueprint or contract between the backend (API developers) and the frontend (or any clients).

  Common API specification formats include:

  * OpenAPI (formerly Swagger) – most popular

  * RAML

  * API Blueprint

  What's Included in an API Specification?

A typical API spec defines:

* Endpoints (URLs)

   e.g., GET /users, POST /login

* Methods

  GET, POST, PUT, DELETE, etc.

* Request Parameters
   
   * Path params: /user/<id>

   * Query params: ?search=term

   * Body data: JSON or form data

* Response Formats
   
   * Status codes (200 OK, 404 Not Found, etc.)

   * JSON structure of the response

   * Authentication details

   * Error messages

Q-19 What are HTTP status codes, and why are they important in a Flask API?

  ANS-- HTTP status codes are three-digit numbers returned by a server in response to an HTTP request. They indicate the result of the request — whether it was successful, had an error, was unauthorized, etc.

These codes are part of the HTTP protocol and are essential in any web API, including Flask APIs.

 Why HTTP Status Codes Are Important in a Flask API:-

 1.Communicate the Result of an API Call

  * Tells the client whether the request succeeded, failed, or needs changes.

  * Example:
    
    200 OK → success
400 Bad Request → client error (e.g., invalid input)

2. Helps with Debugging

  * Clear error codes make it easier to identify what went wrong.

  * A 404 Not Found is more helpful than a generic server error.

3. Enables Consistent API Behavior
  
  * Standardized status codes make your API more predictable and easier to use.

4. Essential for Frontend Integration

 * Frontend developers can programmatically react to different responses.

 * Example: Redirect on 401 Unauthorized, show errors for 400 Bad Request.

Q-20  How do you handle POST requests in Flask?

 ANS-- How to Handle POST Requests in Flask

 1. Defining a route that allows the POST method.

 2. Accessing data sent in the request (e.g., JSON or form data).

 3. Processing the data and returning a response.

Q-21  How would you secure a Flask API?

  ANS-- Securing a Flask API is critical to protect your data, users, and system from unauthorized access, abuse, and attacks. Flask by itself is minimal, so you’ll need to implement several layers of security.

  How to Secure a Flask API

1. Use HTTPS (SSL/TLS)

  * Serve your API over HTTPS, not HTTP.

  * Encrypts data in transit, preventing man-in-the-middle (MITM) attacks.

  * Use a reverse proxy like Nginx with Let's Encrypt for production HTTPS.

2. Authentication

  * Token-Based Authentication

  * JWT (JSON Web Tokens) is commonly used.

  * Clients include a token in the Authorization header:

3. Authorization
  
  Control what an authenticated user can do.

  * Role-based access (e.g., admin vs regular user)

  * Scope-based tokens (OAuth2-style)

  * Custom decorators to restrict access

4. Input Validation & Sanitization

  Always validate and sanitize user input to prevent:

  * SQL Injection

  * XSS (if returning HTML)

  * Command Injection

Q-22  What is the significance of the Flask-RESTful extension?

  ANS-- Flask-RESTful is an extension for Flask that simplifies building RESTful APIs. It provides tools and abstractions to help you create clean, organized, and scalable APIs with minimal boilerplate.


Significance of Flask-RESTful

 1. Class-Based Resource Routing

 Instead of defining routes with functions, you use Python classes to represent API resources.

  EXAMPLE:
    
     from flask_restful import Resource

class HelloWorld(Resource):
    def get(self):
        return {'message': 'Hello, world!'}

2. Automatic Route Binding with api.add_resource()

No need for manual route decorators.

EXAMPLE:
   
   from flask import Flask
from flask_restful import Api

app = Flask(__name__)
api = Api(app)

api.add_resource(HelloWorld, '/')

Q-23  What is the role of Flask’s session object?

  ANS-- Since HTTP is a stateless protocol (it doesn't remember users between requests), the session object provides a way to persist information (like login state or user preferences) across multiple interactions with your Flask app.


 Key Roles of session in Flask

 1. Maintains User State

Stores small amounts of data like:

  * session['username'] = 'alice'

  * session['logged_in'] = True

 2. Cookie-Based Storage

   * Data is stored client-side in a secure cookie.

   * Flask signs the cookie with your app’s SECRET_KEY to prevent tampering.

   * The data is:
      
      * Visible to the client (not encrypted)

      * Tamper-proof (signed to ensure integrity)

  3. Used for Login Sessions
   
 It's commonly used to store:

  * user_id

  * is_admin

  * auth_token

PRACTICAL QUSTIONS

Q- 1  How do you create a basic Flask application?
"""

from flask import Flask

# Create a Flask instance
app = Flask(__name__)

# Define a route
@app.route("/")
def home():
  return "Hello, Flask!"

# Run the app (for development)
# In a real-world application, you would use a production-ready server
if __name__ == "__main__":
  app.run(debug=True)

"""Q-2  How do you serve static files like images or CSS in Flask?"""

from flask import Flask, url_for, render_template

app = Flask(__name__)

@app.route('/')
def index():
  return render_template('index.html')

# To serve static files, place them in a folder named 'static'
# in the same directory as your application file.
# For example, you can have a 'static' folder with 'style.css' inside.
# In your HTML template, you can link to it like this:
#

# Example of an index.html template in a 'templates' folder:
#
#
#
#
#
#
#     Hello from Flask!
#     This is a demonstration of serving static files.
#
#

# Example of a style.css file in a 'static' folder:
# body {
#     font-family: sans-serif;
#     background-color: lightblue;
# }

"""Q-3  How do you define different routes with different HTTP methods in Flask?"""

from flask import Flask, request

app = Flask(__name__)

# Route that accepts GET and POST requests
@app.route('/submit', methods=['GET', 'POST'])
def submit():
    if request.method == 'POST':
        # Handle POST request data
        return 'Received POST request!'
    else:
        # Handle GET request
        return 'Send a POST request to this endpoint.'

# Route that only accepts GET requests (default)
@app.route('/data', methods=['GET'])
def get_data():
    return 'This endpoint only accepts GET requests.'

# Route that only accepts POST requests
@app.route('/create', methods=['POST'])
def create_resource():
    # Handle POST request to create a resource
    return 'Resource created!', 201 # Return 201 Created status code

if __name__ == '__main__':
    app.run(debug=True)

"""Q-4  How do you render HTML templates in Flask?"""

from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def index():
  # Flask looks for templates in a 'templates' folder by default
  return render_template('index.html')

# Example of an index.html template in a 'templates' folder:
#
#
#
#     My Flask App
#
#
#     Hello from an HTML Template!
#     This content is rendered from index.html.
#
#

if __name__ == '__main__':
    app.run(debug=True)

"""Q-5 How can you generate URLs for routes in Flask using url_for?

"""

from flask import Flask, url_for

app = Flask(__name__)

@app.route('/')
def index():
    return 'Hello from the index page!'

@app.route('/user/')
def show_user_profile(username):
    return f'User: {username}'

@app.route('/post/')
def show_post(post_id):
    return f'Post ID: {post_id}'

with app.test_request_context():
    # Generate URL for the 'index' function
    index_url = url_for('index')
    print(f"URL for index: {index_url}")

    # Generate URL for the 'show_user_profile' function with a username
    user_url = url_for('show_user_profile', username='john_doe')
    print(f"URL for user profile: {user_url}")

    # Generate URL for the 'show_post' function with a post ID
    post_url = url_for('show_post', post_id=123)
    print(f"URL for post: {post_url}")

    # Generate URL with query parameters
    next_page_url = url_for('index', next='/')
    print(f"URL with query parameter: {next_page_url}")

"""Q-6 How do you handle forms in Flask?"""

from flask import Flask, request, render_template

app = Flask(__name__)

@app.route('/form', methods=['GET', 'POST'])
def handle_form():
    if request.method == 'POST':
        # Get data from the form
        name = request.form.get('name')
        email = request.form.get('email')
        return f'Thank you, {name}! Your email is {email}.'
    # Render the form template for GET requests
    return render_template('form.html')

# Example of a form.html template in a 'templates' folder:
#
#
#
#     Form Example
#
#
#     Simple Form
#
#         Name:
#
#         Email:
#
#
#
#
#

if __name__ == '__main__':
    app.run(debug=True)

"""Q-7  How can you validate form data in Flask?

"""

from flask import Flask, request, render_template

app = Flask(__name__)

@app.route('/validate_form', methods=['GET', 'POST'])
def validate_form():
    if request.method == 'POST':
        name = request.form.get('name')
        email = request.form.get('email')
        errors = {}

        if not name:
            errors['name'] = 'Name is required.'
        if not email:
            errors['email'] = 'Email is required.'
        elif '@' not in email:
            errors['email'] = 'Invalid email format.'

        if errors:
            # If there are errors, re-render the form with error messages
            return render_template('validate_form.html', errors=errors, name=name, email=email)
        else:
            # If validation passes, process the data
            return f'Form submitted successfully! Name: {name}, Email: {email}'

    # Render the form template for GET requests
    return render_template('validate_form.html')

# Example of a validate_form.html template in a 'templates' folder:
#
#
#
#     Form Validation Example
#
#
#
#     Form Validation
#
#
#             Name:
#
#             {% if errors and errors.name %}{{ errors.name }}{% endif %}
#
#
#
#             Email:
#
#             {% if errors and errors.email %}{{ errors.email }}{% endif %}
#
#
#
#
#
#

if __name__ == '__main__':
    app.run(debug=True)

"""Q-8 How do you manage sessions in Flask?"""

from flask import Flask, session, redirect, url_for, request

app = Flask(__name__)
# Set a secret key for signing the session cookie
# In a real application, use a strong, randomly generated key
app.secret_key = 'your_secret_key'

@app.route('/')
def index():
    if 'username' in session:
        return f'Logged in as {session["username"]}'
    return 'You are not logged in'

@app.route('/login', methods=['GET', 'POST'])
def login():
    if request.method == 'POST':
        session['username'] = request.form['username']
        return redirect(url_for('index'))
    return '''




    '''

@app.route('/logout')
def logout():
    # Remove the username from the session if it's there
    session.pop('username', None)
    return redirect(url_for('index'))

if __name__ == '__main__':
    app.run(debug=True)

"""Q-9 How do you redirect to a different route in Flask?

"""

from flask import Flask, redirect, url_for

app = Flask(__name__)

@app.route('/')
def index():
    return 'This is the index page. You will be redirected to the target page.'

@app.route('/redirect_to_target')
def redirect_example():
    # Redirect to the 'target_page' route
    return redirect(url_for('target_page'))

@app.route('/target')
def target_page():
    return 'You have been redirected to the target page!'

if __name__ == '__main__':
    app.run(debug=True)

"""Q-10 How do you handle errors in Flask (e.g., 404)?

"""

from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def index():
    return 'Hello, this is the index page.'

# Custom error handler for 404 Not Found errors
@app.errorhandler(404)
def page_not_found(error):
    # You can render a custom template or return a simple string
    return render_template('404.html'), 404

# Example of a 404.html template in a 'templates' folder:
#
#
#
#     Page Not Found
#
#
#     Page Not Found
#     The requested URL was not found on the server. If you entered the URL manually please check your spelling and try again.
#
#

if __name__ == '__main__':
    app.run(debug=True)

"""Q-11 How do you structure a Flask app using Blueprints?"""

# app.py
from flask import Flask

def create_app():
    app = Flask(__name__)

    # Register blueprints
    from .main import main as main_blueprint
    app.register_blueprint(main_blueprint)

    from .auth import auth as auth_blueprint
    app.register_blueprint(auth_blueprint, url_prefix='/auth')

    return app

if __name__ == '__main__':
    app = create_app()
    app.run(debug=True)


# main.py (inside a 'main' folder)
from flask import Blueprint

main = Blueprint('main', __name__)

@main.route('/')
def index():
    return 'Hello from the main blueprint!'


# auth.py (inside an 'auth' folder)
from flask import Blueprint

auth = Blueprint('auth', __name__)

@auth.route('/login')
def login():
    return 'This is the login page from the auth blueprint.'

"""Q-12 from flask import Flask, render_template



"""

from flask import Flask, render_template

app = Flask(__name__)

# Define a custom Jinja filter
@app.template_filter('capitalize_words')
def capitalize_words_filter(s):
    return s.title()

@app.route('/')
def index():
    my_text = "hello world"
    return render_template('filter_example.html', my_text=my_text)

# Example of a filter_example.html template in a 'templates' folder:
#
#
#
#     Custom Filter Example
#
#
#     Custom Jinja Filter
#     Original text: {{ my_text }}
#     Text with custom filter: {{ my_text | capitalize_words }}
#
#

if __name__ == '__main__':
    app.run(debug=True)

"""Q-13 How can you redirect with query parameters in Flask?

"""

from flask import Flask, redirect, url_for

app = Flask(__name__)

@app.route('/')
def index():
    return 'This is the index page.'

@app.route('/redirect_with_params')
def redirect_with_params():
    # Redirect to the 'target_page' route with query parameters
    return redirect(url_for('target_page', param1='value1', param2='value2'))

@app.route('/target')
def target_page():
    # You can access the query parameters in the target route using request.args
    from flask import request
    param1 = request.args.get('param1')
    param2 = request.args.get('param2')
    return f'You have been redirected to the target page! Param1: {param1}, Param2: {param2}'

if __name__ == '__main__':
    app.run(debug=True)

"""Q-14 How do you return JSON responses in Flask?"""

from flask import Flask, jsonify

app = Flask(__name__)

@app.route('/data')
def get_data():
    data = {
        'name': 'John Doe',
        'age': 30,
        'city': 'New York'
    }
    return jsonify(data)

@app.route('/list_data')
def get_list_data():
    data = [
        {'id': 1, 'item': 'apple'},
        {'id': 2, 'item': 'banana'}
    ]
    return jsonify(data)

if __name__ == '__main__':
    app.run(debug=True)

"""Q-15 How do you capture URL parameters in Flask?from flask import Flask

"""

app = Flask(__name__)

# Define a route with a URL parameter 'name'
@app.route('/user/')
def show_user(name):
  # The value of the URL parameter 'name' is passed as an argument to the function
  return f'Hello, {name}!'

# Define a route with a URL parameter 'post_id' which is an integer
@app.route('/post/')
def show_post(post_id):
  # The value of the URL parameter 'post_id' is passed as an integer argument
  return f'Post ID: {post_id}'

if __name__ == '__main__':
  app.run(debug=True)